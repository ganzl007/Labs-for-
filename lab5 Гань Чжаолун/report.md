# Отчёт по лабораторной работе №5
### Построение графиков
## Гань Чжаолун

<div STYLE="page-break-after: always;"></div>

# Цель работы

Основная цель работы — освоить синтаксис языка Julia для построения графиков.

# Выполнение лабораторной работы

![](image/2.1.1.png)

Рисунок 1.1 Основные пакеты для работы с графиками в Julia 1

![](image/2.1.2.png)

Рисунок 1.2 Основные пакеты для работы с графиками в Julia 2

![](image/2.1.3.png)

Рисунок 1.3 Основные пакеты для работы с графиками в Julia 3

![](image/2.2.1.png)

Рисунок 1.4 Опции при построении графика 1

![](image/2.2.2.png)

Рисунок 1.5 Опции при построении графика 2

![](image/2.2.3.png)

Рисунок 1.6 Опции при построении графика 3

![](image/2.3.1.png)

Рисунок 1.7 Точечный график 1

![](image/2.3.2.png)

Рисунок 1.8 Точечный график 2

![](image/2.3.3.png)

Рисунок 1.9 Точечный график 3

![](image/2.4.png)

Рисунок 1.10 Аппроксимация данных

![](image/2.5.png)

Рисунок 1.11 Две оси ординат

![](image/2.6.png)

Рисунок 1.12 Полярные координаты

![](image/2.7.1.png)

Рисунок 1.13 Параметрический график 1

![](image/2.7.2.png)

Рисунок 1.14 Параметрический график 2

![](image/2.8.1.png)

Рисунок 1.15 График поверхности 1

![](image/2.8.2.png)

Рисунок 1.16 График поверхности 2

![](image/2.9.1.png)

Рисунок 1.17 Линии уровня 1

![](image/2.9.2.png)

Рисунок 1.18 Линии уровня 2

![](image/2.10.1.png)

Рисунок 1.19 Векторные поля 1

![](image/2.10.2.png)

Рисунок 1.20 Векторные поля 2

![](image/2.11.1.1.png)

Рисунок 1.21 Векторные поля 3

![](image/2.11.1.2.png)

Рисунок 1.22 Векторные поля 4

![](image/2.11.2.1.png)

Рисунок 1.23 Векторные поля 5

![](image/2.11.2.2.png)

Рисунок 1.24 Векторные поля 6

![](image/2.11.2.3.png)

Рисунок 1.25 Векторные поля 7

![](image/2.11.2.4.png)

Рисунок 1.26 Векторные поля 8

![](image/2.11.2.5.png)

Рисунок 1.27 Векторные поля 9

![](image/2.12.1.png)

Рисунок 1.28 Errorbars 1

![](image/2.12.2.png)

Рисунок 1.29 Errorbars 2

![](image/2.12.3.png)

Рисунок 1.30 Errorbars 3

![](image/2.13.1.png)

Рисунок 1.31 Использование пакета Distributions 1

![](image/2.13.2.png)

Рисунок 1.32 Использование пакета Distributions 2

![](image/2.14.1.png)

Рисунок 1.33 Подграфики 1

![](image/2.14.2.png)

Рисунок 1.34 Подграфики 2

![](image/2.14.3.png)

Рисунок 1.35 Подграфики 3

### Задания для самостоятельного выполнения

![](image/h1.png)

Рисунок 2.1 Код и результат Задания 1

<font color=Blue>
Моя основная идея заключалась в том, чтобы сначала определить набор данных для функции `y = sin(x)` в диапазоне от `0` до `2π`. Затем я последовательно построил несколько типов графиков на основе этих данных: простой линейный график (plot), точечный график (scatter) и две гистограммы (histogram) с разным количеством столбцов (bins). Наконец, я совместил все эти графики в одном общем оконном представлении, используя функцию `plot` с параметром `layout`. Такой подход позволяет наглядно сравнить различные типы визуализации для одних и тех же данных.</font>

![](image/h2.png)

Рисунок 2.2 Код и результат Задания 2

<font color=Blue>
Я сначала определил массив точек для функции `y = sin(x)` в заданном диапазоне `0` до `2π`, а затем построил несколько графиков, меняя типы и стили линий — от сплошной и пунктирной до точечной и комбинированной ("dashdot"). После этого я расположил все полученные графики в одном окне, чтобы можно было наглядно сравнить различные варианты оформления линий.</font>

![](image/h3.png)

Рисунок 2.3 Код и результат Задания 3

<font color=Blue>
Я сначала определил функцию  и сгенерировал точки по оси  в требуемом интервале. Затем построил график, придав ему все необходимые свойства: цвет линии — красный, цвет рамки (границы графической области) — зелёный, соответствующие подписи осей с заданным шрифтом, отступы и частоту отметок на осях. В итоге, все настройки визуализации были применены так, чтобы надписи и оси были аккуратно расположены и удобно читаемы.</font>

![](image/h4.1.png)

Рисунок 2.4.1 Код и результат Задания 4.1

![](image/h4.2.png)

Рисунок 2.4.2 Код и результат Задания 4.2

<font color=Blue>
Я сначала определил функцию  и выбрал набор точек  для оценки этой функции. Затем я построил несколько вариантов графиков, используя один и тот же набор данных: в одном подграфике я изобразил точки (scatter), в другом — линии (sticks), в третьем — сочетание линий и точек (step с маркерами), и, наконец, в четвёртом — простую кривую (line). После этого я расположил все четыре вида графических представлений в одном общем окне в виде сетки из четырёх подграфиков. Такой подход позволил мне наглядно сравнить различные способы визуализации одних и тех же данных.</font>

![](image/h5.1.png)

Рисунок 2.5.1 Код и результат Задания 5.1

![](image/h5.2.png)

Рисунок 2.5.2 Код и результат Задания 5.2

<font color=Blue>
Мой основной подход заключался в том, чтобы сначала определить функции , а затем построить их на одном наборе точек . Я создал два графика. В первом варианте оба графика были отображены на одной координатной сетке с общей осью ординат, использовал разный цвет и легенду для каждой функции, а также включил сетку. Во втором варианте я воспользовался двумя осями ординат: одну оставил для (y_1), другую добавил с помощью `twinx()` для (y_2). Таким образом, каждый график имел свою вертикальную шкалу, что позволило более наглядно сравнивать их.</font>

![](image/h6.png)

Рисунок 2.6 Код и результат Задания 6

<font color=Blue>
Я решил сгенерировать набор экспериментальных данных, основываясь на простой функции , и использовать случайные значения (x) для придания имитации неопределённости. Затем я вычислил значения (y_3) и задал ошибку измерения как некоторую пропорциональную величину от значения функции, делённую на корень из количества точек. В конце я построил график с использованием ошибок, чтобы визуализировать разброс данных и показать, как может выглядеть экспериментальная неопределённость измерений.</font>

![](image/h7.png)

Рисунок 2.7 Код и результат Задания 7

<font color=Blue>
Я сгенерировал два набора случайных чисел для осей (x) и (y), затем построил точечный график, отобразив каждую пару (x_i, y_i) в виде отдельной точки. Добавил подписи к осям, легенду и заголовок, чтобы график был понятен и информативен. Такой подход даёт быстрое визуальное представление о распределении случайных данных.</font>

![](image/h8.png)

Рисунок 2.8 Код и результат Задания 8

<font color=Blue>
Я сгенерировал три набора случайных чисел для координат (x), (y) и (z), а затем построил трёхмерный точечный график. Для удобства интерпретации я добавил подписи к осям, легенду и заголовок графика. Таким образом, я получил наглядное 3D-представление случайных данных, показывающее их распределение в пространстве.</font>

![](image/h9.png)

Рисунок 2.9 Код и результат Задания 9

<font color=Blue>
Я захотел создать анимацию, показывающую, как синусоида «нарастает» с увеличением аргумента. Для этого я сначала сформировал вектор значений (x), затем пошагово — от кадра к кадру — добавлял всё больше точек на график, вычисляя для них значение sin(x). С помощью цикла и макроса `@animate` я генерировал последовательность кадров, а затем превратил её в GIF-анимацию. Таким образом, по мере продвижения по циклу синусоида постепенно удлиняется, наглядно демонстрируя процесс построения кривой.</font>

![](image/h10.1.png)

Рисунок 2.10.1 Код и результат Задания 10.1

![](image/h10.2.png)

Рисунок 2.10.2 Код и результат Задания 10.2

![](image/h10.3.png)

Рисунок 2.10.3 Код и результат Задания 10.3

![](image/h10.4.png)

Рисунок 2.10.4 Код и результат Задания 10.4

![](image/h10.5.png)

Рисунок 2.10.5 Код и результат Задания 10.5

<font color=Blue>
Я решил визуализировать гипоциклоиду, постепенно «прорисовывая» её траекторию и показывая процесс вращения маленькой окружности по внутренней стороне большой. Для этого я создал функцию, которая на заданном интервале угла строит координаты большой окружности, малой окружности и самой гипоциклоиды. Затем я использовал цикл анимации (`@animate`), который по шагам добавляет новые точки на траектории, позволяя увидеть, как форма развивается во времени. Поменяв параметр (k) (отношение радиусов окружностей), я получил разные варианты гипоциклоид. В итоге, каждая анимация сохраняется в GIF-файл, наглядно демонстрируя процесс построения фигуры для разных значений (k).</font>

![](image/h11.1.png)

Рисунок 2.11.1 Код и результат Задания 11.1

![](image/h11.2.png)

Рисунок 2.11.2 Код и результат Задания 11.2

![](image/h11.3.png)

Рисунок 2.11.3 Код и результат Задания 11.3

![](image/h11.4.png)

Рисунок 2.11.4 Код и результат Задания 11.4

![](image/h11.5.png)

Рисунок 2.11.5 Код и результат Задания 11.5

<font color=Blue>
Я захотел наглядно показать построение эпициклоиды при различных значениях параметра (k). Для этого я написал функцию, которая для заданных (k), радиуса (r_0) и количества шагов (n) генерирует точки большой и малой окружностей, а также координаты эпициклоиды на каждом шаге, постепенно «прорисовывая» её траекторию. В цикле анимации на каждом кадре я добавляю всё больше точек, показывая, как фигура формируется во времени. Изменяя значение (k), я получил различные характерные формы эпициклоиды. После завершения построения всех кадров я сохранил анимацию в виде GIF-файла.</font>

# Вывод

Я освоил синтаксис языка Julia для построения графиков.
