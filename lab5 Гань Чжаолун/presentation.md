---
## Front matter
lang: ru-RU
title: Построение графиков
author: |
	 Гань Чжаолун\inst{1}

institute: |
	\inst{1}Российский Университет Дружбы Народов

date: 13 декабрь, 2024, Москва, Россия

## Formatting
mainfont: PT Serif
romanfont: PT Serif
sansfont: PT Sans
monofont: PT Mono
toc: false
slide_level: 2
theme: metropolis
header-includes: 
 - \metroset{progressbar=frametitle,sectionpage=progressbar,numbering=fraction}
 - '\makeatletter'
 - '\beamer@ignorenonframefalse'
 - '\makeatother'
aspectratio: 43
section-titles: true

---

# Цели и задачи работы

Основная цель работы — освоить синтаксис языка Julia для построения графиков.

# Цель лабораторной работы

### Используя Jupyter Lab, повторите примеры из раздела 5.2.

Я повторю все задание 5.2 целиком

### Задания для самостоятельного выполнения

![](image/h1.png)

Рисунок 1 Код и результат Задания 1

<font color=Blue>
Моя основная идея заключалась в том, чтобы сначала определить набор данных для функции `y = sin(x)` в диапазоне от `0` до `2π`. Затем я последовательно построил несколько типов графиков на основе этих данных: простой линейный график (plot), точечный график (scatter) и две гистограммы (histogram) с разным количеством столбцов (bins). Наконец, я совместил все эти графики в одном общем оконном представлении, используя функцию `plot` с параметром `layout`. Такой подход позволяет наглядно сравнить различные типы визуализации для одних и тех же данных.</font>

![](image/h2.png)

Рисунок 2 Код и результат Задания 2

<font color=Blue>
Я сначала определил массив точек для функции `y = sin(x)` в заданном диапазоне `0` до `2π`, а затем построил несколько графиков, меняя типы и стили линий — от сплошной и пунктирной до точечной и комбинированной ("dashdot"). После этого я расположил все полученные графики в одном окне, чтобы можно было наглядно сравнить различные варианты оформления линий.</font>

![](image/h3.png)

Рисунок 3 Код и результат Задания 3

<font color=Blue>
Я сначала определил функцию  и сгенерировал точки по оси  в требуемом интервале. Затем построил график, придав ему все необходимые свойства: цвет линии — красный, цвет рамки (границы графической области) — зелёный, соответствующие подписи осей с заданным шрифтом, отступы и частоту отметок на осях. В итоге, все настройки визуализации были применены так, чтобы надписи и оси были аккуратно расположены и удобно читаемы.</font>

![](image/h4.1.png)


![](image/h4.2.png)

Рисунок 4 Код и результат Задания 4.2

<font color=Blue>
Я сначала определил функцию  и выбрал набор точек  для оценки этой функции. Затем я построил несколько вариантов графиков, используя один и тот же набор данных: в одном подграфике я изобразил точки (scatter), в другом — линии (sticks), в третьем — сочетание линий и точек (step с маркерами), и, наконец, в четвёртом — простую кривую (line). После этого я расположил все четыре вида графических представлений в одном общем окне в виде сетки из четырёх подграфиков. Такой подход позволил мне наглядно сравнить различные способы визуализации одних и тех же данных.</font>

![](image/h5.1.png)


![](image/h5.2.png)

Рисунок 5 Код и результат Задания 5.2

<font color=Blue>
Мой основной подход заключался в том, чтобы сначала определить функции , а затем построить их на одном наборе точек . Я создал два графика. В первом варианте оба графика были отображены на одной координатной сетке с общей осью ординат, использовал разный цвет и легенду для каждой функции, а также включил сетку. Во втором варианте я воспользовался двумя осями ординат: одну оставил для (y_1), другую добавил с помощью `twinx()` для (y_2). Таким образом, каждый график имел свою вертикальную шкалу, что позволило более наглядно сравнивать их.</font>

![](image/h6.png)

Рисунок 6 Код и результат Задания 6

<font color=Blue>
Я решил сгенерировать набор экспериментальных данных, основываясь на простой функции , и использовать случайные значения (x) для придания имитации неопределённости. Затем я вычислил значения (y_3) и задал ошибку измерения как некоторую пропорциональную величину от значения функции, делённую на корень из количества точек. В конце я построил график с использованием ошибок, чтобы визуализировать разброс данных и показать, как может выглядеть экспериментальная неопределённость измерений.</font>

![](image/h7.png)

Рисунок 7 Код и результат Задания 7

<font color=Blue>
Я сгенерировал два набора случайных чисел для осей (x) и (y), затем построил точечный график, отобразив каждую пару (x_i, y_i) в виде отдельной точки. Добавил подписи к осям, легенду и заголовок, чтобы график был понятен и информативен. Такой подход даёт быстрое визуальное представление о распределении случайных данных.</font>

![](image/h8.png)

Рисунок 8 Код и результат Задания 8

<font color=Blue>
Я сгенерировал три набора случайных чисел для координат (x), (y) и (z), а затем построил трёхмерный точечный график. Для удобства интерпретации я добавил подписи к осям, легенду и заголовок графика. Таким образом, я получил наглядное 3D-представление случайных данных, показывающее их распределение в пространстве.</font>

![](image/h9.png)

Рисунок 9 Код и результат Задания 9

<font color=Blue>
Я захотел создать анимацию, показывающую, как синусоида «нарастает» с увеличением аргумента. Для этого я сначала сформировал вектор значений (x), затем пошагово — от кадра к кадру — добавлял всё больше точек на график, вычисляя для них значение sin(x). С помощью цикла и макроса `@animate` я генерировал последовательность кадров, а затем превратил её в GIF-анимацию. Таким образом, по мере продвижения по циклу синусоида постепенно удлиняется, наглядно демонстрируя процесс построения кривой.</font>

![](image/h10.1.png)


![](image/h10.2.png)


![](image/h10.3.png)


![](image/h10.4.png)


![](image/h10.5.png)

Рисунок 10 Код и результат Задания 10.5

<font color=Blue>
Я решил визуализировать гипоциклоиду, постепенно «прорисовывая» её траекторию и показывая процесс вращения маленькой окружности по внутренней стороне большой. Для этого я создал функцию, которая на заданном интервале угла строит координаты большой окружности, малой окружности и самой гипоциклоиды. Затем я использовал цикл анимации (`@animate`), который по шагам добавляет новые точки на траектории, позволяя увидеть, как форма развивается во времени. Поменяв параметр (k) (отношение радиусов окружностей), я получил разные варианты гипоциклоид. В итоге, каждая анимация сохраняется в GIF-файл, наглядно демонстрируя процесс построения фигуры для разных значений (k).</font>

![](image/h11.1.png)


![](image/h11.2.png)


![](image/h11.3.png)


![](image/h11.4.png)


![](image/h11.5.png)

Рисунок 11 Код и результат Задания 11.5

<font color=Blue>
Я захотел наглядно показать построение эпициклоиды при различных значениях параметра (k). Для этого я написал функцию, которая для заданных (k), радиуса (r_0) и количества шагов (n) генерирует точки большой и малой окружностей, а также координаты эпициклоиды на каждом шаге, постепенно «прорисовывая» её траекторию. В цикле анимации на каждом кадре я добавляю всё больше точек, показывая, как фигура формируется во времени. Изменяя значение (k), я получил различные характерные формы эпициклоиды. После завершения построения всех кадров я сохранил анимацию в виде GIF-файла.</font>


# Вывод

Я освоил синтаксис языка Julia для построения графиков.
